package code;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Time Complexity: O(4^n / sqrt(n))
 * Space Complexity: O(4^n / sqrt(n))
 *
 * Logic of the question works as below:
 * Eg: Take n = 3.
 * Each step, the recursion goes like this.
 * 1. (
 * 2.    ((
 * 3.         (((
 * 4.             ((()
 * 5.                  ((())
 * 6.                     ((())) - 1 combination
 * 7.    (()
 *          (())
 *              (())(
 *                  (())()
 *
 * 8. ()()()
 * .
 * .
 * .
 * .
 *
 * And so on all the combinations are generated by rolling the current string with each recursion
 * and passing through the backtrack stage of each step.
 */
public class GenerateParentheses {


    public List<String> generateParenthesis(int n) {
        List<String> result = new ArrayList<>();
        recursiveBackTrack(n, result, "", 0, 0);
        return result;
    }

    void recursiveBackTrack(int n, List<String> result, String current, int left, int right) {
        if (current.length() == n * 2) {
            result.add(current);
            return;
        }

        if (left < n) {
            recursiveBackTrack(n, result, current + "(", left + 1, right);
        }
        if (right < left) {
            recursiveBackTrack(n, result, current + ")", left, right + 1);
        }
    }

    public static void main(String[] args) {
        System.out.println(new GenerateParentheses().generateParenthesis(3));
    }

}
